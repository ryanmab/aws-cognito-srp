use base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};
use chrono::Utc;
use digest::Digest;
use log::info;
use num_bigint::{BigInt, BigUint, Sign};
use rand::{Rng, RngCore};
use regex::Regex;

use crate::constant::{DERIVE_KEY_INFO, G, N};

/// Generate client's secret `a` value for the client.
///
/// This is a random 128 byte value.
pub fn generate_a(rand: &mut impl RngCore) -> Vec<u8> {
    let mut a = [0u8; 128];
    rand.fill_bytes(&mut a);

    a.to_vec()
}

/// Compute the public key `A` from the client's secret key `a` (as generated by [`generate_a`]).
pub fn compute_pub_a(a: &[u8]) -> Vec<u8> {
    G.modpow(&BigUint::from_bytes_be(a), &N).to_bytes_be()
}

/// Compute the public key B from the servers public key (transmitted via `SRP_B` in the
/// AWS Cognito challenge).
pub fn compute_pub_b(b: &[u8]) -> Vec<u8> {
    BigUint::from_bytes_be(b).to_bytes_be()
}

/// Compute the SHA256 of `<salt><identity>`.
///
/// Parameters are as follows:
/// - `salt` - The value given back by Cognito in the challenge via the `SALT` parameter.
/// - `identity` - The hash computed by [`crate::client::user::helper::compute_identity`].
pub fn compute_x<D: Digest>(identity: &[u8], salt: &[u8]) -> BigUint {
    let mut x = D::new();
    x.update(left_pad(salt, 0).as_slice());
    x.update(identity);
    BigUint::from_bytes_be(&x.finalize())
}

/// Compute the shared secret
pub fn compute_s(a: &[u8], u: &BigUint, x: &BigUint, k: BigUint, b: &[u8]) -> BigInt {
    let g_mod_pow_xn = G.modpow(x, &N);
    let int_value2 =
        BigInt::from_bytes_be(Sign::Plus, b) - BigInt::from_biguint(Sign::Plus, k * g_mod_pow_xn);

    int_value2.modpow(
        &BigInt::from_biguint(Sign::Plus, BigUint::from_bytes_be(a) + (u * x)),
        &BigInt::from_bytes_be(Sign::Plus, &N.to_bytes_be()),
    )
}

/// Compute the SRP `k` (Multiplier parameter) value.
///
/// AWS Cognito uses SRP-6a specification, so `k` is calculated as the hash of [`crate::constant::N`] and
/// [`crate::constant::G`].
pub fn compute_k<D: Digest>() -> BigUint {
    let mut digest = D::new();
    digest.update([0]);
    digest.update(N.to_bytes_be());
    digest.update(G.to_bytes_be());
    BigUint::from_bytes_be(digest.finalize().as_slice())
}

/// The value of preventing attacker who learns a user's verifier
pub fn compute_u<D: Digest>(a_pub: &[u8], b_pub: &[u8]) -> BigUint {
    let mut u = D::new();
    u.update(left_pad(a_pub, 0));
    u.update(left_pad(b_pub, 0));
    BigUint::from_bytes_be(&u.finalize())
}

/// Generate a random UTF-8 password (40 bytes), which can be used as a
/// device password.
pub fn generate_password(mut rand: impl RngCore) -> String {
    let mut password_random = [0u8; 40];
    rand.fill(&mut password_random[..]);
    BASE64.encode(password_random)
}

/// Generate a random salt (16 bytes) which can be used to generate a verifier.
pub fn generate_salt(mut rand: impl RngCore) -> Vec<u8> {
    let mut salt = [0u8; 16];
    rand.fill(&mut salt[..]);
    left_pad(hex::encode(salt).as_bytes(), 0)
}

/// Generate the derive data used when generating Authentication
/// keys for Device and User verification.
///
/// [https://github.com/aws-samples/aws-cognito-java-desktop-app/blob/master/src/main/java/com/amazonaws/sample/cognitoui/AuthenticationHelper.java#L56]
pub fn generate_key_derive_data() -> Vec<u8> {
    let mut key_derive_data: Vec<u8> = vec![];
    key_derive_data.extend_from_slice(DERIVE_KEY_INFO.as_bytes());
    key_derive_data.extend_from_slice(&[1]);

    key_derive_data
}

/// Get a timestamp in the format required by AWS Cognito.
///
/// Specifically AWS Cognito requires any preceding 0's are removed from the start of
/// the day number: `Thu Jan 1 00:00:00 UTC 1970`.
#[cfg(not(test))]
pub fn get_timestamp() -> String {
    let timestamp = Regex::new(r" 0(\d) ")
        .unwrap()
        .replace_all(
            &Utc::now().format("%a %b %d %H:%M:%S UTC %Y").to_string(),
            " $1 ",
        )
        .to_string();

    info!("Generated timestamp for SRP calculations: {}", timestamp);

    timestamp
}

#[cfg(test)]
pub fn get_timestamp() -> String {
    "Mon Feb 10 18:30:12 UTC 2025".into()
}

/// Add left padding to a slice of bytes - where an empty slice, or a slice where the first
/// byte is less than 128 is unchanged
pub fn left_pad(data: &[u8], character: u8) -> Vec<u8> {
    if data.is_empty() {
        return vec![];
    }

    if data[0] < 128 {
        return data.to_vec();
    }

    let mut bytes: Vec<u8> = vec![];
    bytes.extend_from_slice(&[character]);
    bytes.extend_from_slice(data);

    bytes
}

/// Add left padding to a hex string (such as SRP_B) to ensure it is an even
/// length, before being decoded.
pub fn left_pad_to_even_length(data: &str, character: char) -> String {
    if data.len() % 2 == 0 {
        return data.to_string();
    }

    format!("{}{}", character, data)
}
